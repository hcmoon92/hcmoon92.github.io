<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vis.js Mind Map from Markdown</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-chtml.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" />
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    #network {
      width: 100%;
      height: 100%;
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <div id="network"></div>
  <script>
    // Function to parse Markdown into a tree structure
    function markdownToTree(markdown) {
      const lines = markdown.split('\n');
      const tree = [];
      const stack = [{ children: tree, level: 0 }];

      lines.forEach(line => {
        const match = line.match(/^(#{1,6})\s*(.*)/); // Match headers (#, ##, etc.)
        if (match) {
          const level = match[1].length; // Header level
          const text = match[2];

          const node = { text, children: [] };

          // Find the parent based on header level
          while (stack[stack.length - 1].level >= level) {
            stack.pop();
          }

          stack[stack.length - 1].children.push(node);
          stack.push({ ...node, level });
        }
      });

      return tree;
    }

    // Convert tree structure to vis.js nodes and edges
    function treeToVis(tree, parentId = null, idStart = 1) {
      const nodes = [];
      const edges = [];
      let id = idStart;

      function traverse(nodesArray, parentId) {
        nodesArray.forEach(node => {
          const nodeId = id++;
          nodes.push({ id: nodeId, label: node.text, title: marked.parse(node.text) });

          if (parentId !== null) {
            edges.push({ from: parentId, to: nodeId });
          }
          if (node.children) {
            traverse(node.children, nodeId);
          }
        });
      }

      traverse(tree, parentId);

      return { nodes, edges };
    }

    // Sample Markdown
    const markdown = `
# Root Node
## Sub Node 1
Math: \\(E = mc^2\\)

Table:
| Header 1 | Header 2 |
|----------|----------|
| Value 1  | Value 2  |

## Sub Node 2
Math: \\(a^2 + b^2 = c^2\\)
### Sub Sub Node
Details: This is a deeper node.
`;

    // Convert Markdown to Tree
    const tree = markdownToTree(markdown);

    // Convert Tree to vis.js Data
    const { nodes, edges } = treeToVis(tree);

    // Initialize vis.js Network
    const container = document.getElementById('network');
    const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
    const options = {
      layout: {
        hierarchical: {
          direction: 'UD', // Up-Down layout
          sortMethod: 'directed',
        },
      },
      physics: false,
      nodes: {
        shape: 'box',
        font: {
          multi: true,
        },
      },
      interaction: {
        tooltipDelay: 200,
      },
    };

    const network = new vis.Network(container, data, options);

    // Process MathJax after rendering
    network.on('afterDrawing', () => {
      MathJax.typesetPromise();
    });
  </script>
</body>
</html>
